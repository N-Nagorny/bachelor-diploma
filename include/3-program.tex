\section{Программная реализация}

В рамках курсовой работы был разработан прототип программного обеспечения, рассчитывающего электродинамические структуры методом конечных разностей во временной области с использованием графического процессора. Применение ГПУ было призвано улучшить производительность вычислений.

\subsection{Программная реализация сетки И}

Разработка программы велась на языке С++, поэтому в качестве программного представления сетки И было решено использовать тип данных «класс». Входными аргументами конструктора класса выступают линейные размеры сетки в ячейках и величины $ \Delta{x} $, $ \Delta{y} $, $ \Delta{z} $, $ \Delta{t} $.

Из рис.~\ref{fig:YeeGrid} легко заметить, что все данные сетки (значения диэлектрической и магнитной проницаемости, удельной электрической и магнитной проводимостей, проекций векторов электрической и магнитной напряжённостей поля на координатные оси) представляют собой трёхмерные массивы с номерами ячеек $ i $, $ j $, $ k $ в качестве индексов.

\subsection{Базовый алгоритм FDTD}

Первым этапом создания программной реализации метода конечных разностей во временной области стало выделение из формул базового алгоритма коэффициентов и написание функций для их расчёта. Неизменность коэффициентов позволяет рассчитывать их единожды при старте программы и использовать готовые значения при пересчёте характеристик поля в каждой ячейке в каждый момент времени.

\begin{equation}
\label{eq:CDCoeffs}
    \newcommand\XA{\displaystyle
        \frac{\Delta{t}}{P}}
    \newcommand\XB{\displaystyle
        \frac{\sigma\Delta{t}}{2P}}
    % --
    C = \frac{\XA}{1+\XB}, \quad
    D = \frac{1-\XB}{1+\XB}.
\end{equation}

Данные коэффициенты приведены в формуле~\eqref{eq:CDCoeffs}, где $ P $ --- проницаемость материала (диэлектрическая и магнитная для проекций векторов $\vec{E}$  и $\vec{H}$ соответственно), а $\sigma$ --- удельная проводимость (электрическая и магнитная для проекций векторов $\vec{E}$  и $\vec{H}$ соответственно).

Следующим шагом стало написание функций, предназначенных для расчёта проекций векторов электрической и магнитной напряжённости во всех точках счётного объёма в какой-либо момент времени. Программный код, производящий расчёт компонент вектора магнитной напряжённости, приведён в листинге~\ref{lst:HCPU}.

\begin{lstlisting}[caption={Код расчёта компоненты вектора магнитной напряжённости на ЦПУ},label={lst:HCPU},language=C++, float, floatplacement=p]
    int nx = grid.Hx.getCountX();
    int ny = grid.Hx.getCountY();
    int nz = grid.Hx.getCountZ();

    float delta_x = grid.delta_x;
    float delta_y = grid.delta_y;
    float delta_z = grid.delta_z;

    for(int ix = 0; ix < nx-1; ix++)
    for(int iy = 0; iy < ny-1; iy++)
    for(int iz = 0; iz < nz-1; iz++) {
        float& curHx      = grid.Hx          .at(ix,   iy,   iz);
        float  curD_Hx    = grid.D_Hx        .at(ix,   iy,   iz);
        float  curEz1     = grid.Ez          .at(ix,   iy+1, iz);
        float  curEz0     = grid.Ez          .at(ix,   iy,   iz);
        float  curEy1     = grid.Ey          .at(ix,   iy,   iz+1);
        float  curEy0     = grid.Ey          .at(ix,   iy,   iz);

        curHx -= curD_Hx * ((curEz1 - curEz0) / delta_y -
                            (curEy1 - curEy0) / delta_z);
    }
\end{lstlisting}

\subsection{Тестовая задача}

Симметричный вибратор --- простейшая система для получения электромагнитных колебаний. Представляет собой электрический диполь, дипольный момент которого быстро изменяется во времени, и является развёрнутым колебательным контуром с минимальной ёмкостью и индуктивностью.

В исходном коде конечной программы симметричный вибратор был представлен двадцатью ячейками счётного объёма, расположенными вдоль оси~$ Z $, с отличными от остальных удельной электрической проводимостью материала~$\sigma$
и абсолютной диэлектрической проницаемостью материала~$\varepsilon$. Длина волны была подобрана таким образом, чтобы отношение длины диполя к длине волны было равно двум.

\subsection{Реализация резистивного источника}

Следующим этапом моделирования резистивного источника стал пересчёт
значений проекции вектора $ \vec{E} $ на ось~$ Z $. Во избежание проверки каждой ячейки на наличие там проводящих структур было принято решение сохранять информацию обо всех ячейках до расчёта значений вектора электрической напряжённости, затем выполнять этот расчёт и, наконец, пересчёт значений проекции
вектора~$ \vec{E} $ на ось~$ Z $ только в точках присутствия элементов источника.

\subsection{Перенос вычислительной нагрузки на графический процессор}

В целях увеличения производительности функции расчёта значений про-
екций векторов электрической и магнитной напряжённостей были изменены
для исполнения на графических процессорах. Из двух технологий, позволяю-
щих осуществить расчёт на GPU: NVIDIA CUDA и OpenCL --- была выбрана
вторая, так как она поддерживает процессоры не только производства компа-
нии NVIDIA, но и AMD.

Для облегчения работы с фреймворком OpenCL была использована библиотека EasyCL. Код расчёта компонент вектора магнитной напряжённости
приведён на листинге~\ref{HGPU}.

\begin{lstlisting}[caption={Код расчёта компоненты вектора магнитной напряжённости на ГПУ},label={lst:HGPU},language=C++, float, floatplacement=p]
__kernel void calcH(int nx, int ny, int nz, float delta_x, float delta_y, float delta_z,
    __global float *Ex,
    __global float *Ey,
    __global float *Ez,
    __global float *Hx,
    __global float *Hy,
    __global float *Hz,
    __global float *D_Hx,
    __global float *D_Hy,
    __global float *D_Hz) {

    int ix = get_global_id(0);
    int iy = get_global_id(1);
    int iz = get_global_id(2);

    int idx = ix * ny * nz + iy * nz + iz;

    int idx010 = ix * ny * nz + (iy + 1) * nz + iz;
    int idx001 = ix * ny * nz + iy * nz + (iz + 1);
    int idx100 = (ix + 1) * ny * nz + iy * nz + iz;

        Hx[idx] -= D_Hx[idx] * ((Ez[idx010] - Ez[idx]) / delta_y -
                            (Ey[idx001] - Ey[idx]) / delta_z);

        Hy[idx] -= D_Hy[idx] * ((Ex[idx001] - Ex[idx]) / delta_z -
                            (Ez[idx100] - Ez[idx]) / delta_x);


        Hz[idx] -= D_Hz[idx] * ((Ey[idx100] - Ey[idx]) / delta_x -
                            (Ex[idx010] - Ex[idx]) / delta_y);
}
\end{lstlisting}
\clearpage